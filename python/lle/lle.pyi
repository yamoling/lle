from . import exceptions
# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import lle.tiles
import numpy
import numpy.typing
import typing
from . import tiles
from enum import Enum

__version__: builtins.str
class Agent:
    r"""
    An agent in the world.
    """
    num: builtins.int
    r"""
    The agent id.
    """
    is_dead: builtins.bool
    r"""
    Whether the agent is dead or not.
    """
    is_alive: builtins.bool
    r"""
    Whether the agent is alive or not.
    """
    has_arrived: builtins.bool
    r"""
    Whether the agent has reached an exit or not.
    """

class World:
    r"""
    The `World` represents the environment in which the agents evolve.
    A world is created from a string where each character represents a tile.
    There are 6 predefined levels for convenience.
    
    ```python
    from lle import World
    # Create from a predefined level
    w1 = World.level(5)
    # Create from a file
    w2 = World.from_file("my_map.txt")
    # Create from a string
    w3 = World("S0 X")
    ```
    """
    exit_pos: builtins.list[tuple[builtins.int, builtins.int]]
    r"""
    The positions of the exits tiles.
    """
    random_start_pos: builtins.list[builtins.list[tuple[builtins.int, builtins.int]]]
    r"""
    The possible random start positions of each agent.
    """
    wall_pos: builtins.list[tuple[builtins.int, builtins.int]]
    r"""
    The positions of the walls.
    """
    void_pos: builtins.list[tuple[builtins.int, builtins.int]]
    r"""
    The positions of the void tiles.
    """
    height: builtins.int
    r"""
    The height of the world (in number of tiles).
    """
    width: builtins.int
    r"""
    The width of the world (in number of tiles).
    """
    n_gems: builtins.int
    r"""
    The number of gems in the world.
    """
    n_agents: builtins.int
    r"""
    The number of agents in the world.
    """
    world_string: builtins.str
    r"""
    Compute the world configuration string from the `World`.
    If possible, the string is returned in "plain text" format.
    Otherwise, it is returned in toml format.
    """
    image_dimensions: tuple[builtins.int, builtins.int]
    r"""
    The dimensions (in pixels) of the image redered (width, height)
    """
    gems_collected: builtins.int
    r"""
    The number of gems collected by the agents so far since the last reset.
    """
    agents_positions: builtins.list[tuple[builtins.int, builtins.int]]
    r"""
    The (i, j) position of each agent.
    """
    gems:  list[tiles.Gem]
    r"""
    All the gems of the environment.
    """
    lasers:  list[tiles.Laser]
    r"""
    Every laser tile in the world.
    """
    laser_sources:  list[tiles.LaserSource]
    r"""
    All the laser sources of the environment
    """
    start_pos: builtins.list[tuple[builtins.int, builtins.int]]
    r"""
    The start position of each agent for this reset.
    """
    agents: builtins.list[Agent]
    r"""
    The list of agents in the world.
    """
    n_laser_colours: builtins.int
    r"""
    The number of different laser colours in the world.
    """
    def __new__(cls, map_str:builtins.str) -> World: ...
    def __init__(self, map_str:builtins.str) -> None:
        r"""
        Constructs a World from a string.
        
        Raises:
            - `RuntimeError`: if the file is not a valid level.
            - `ValueError` if the file is not a valid level (inconsistent dimensions or invalid grid).
        """
    @staticmethod
    def from_file(filename:builtins.str) -> World:
        r"""
        Parse the content of `filename` to create a World.
        
        The file can either be a toml or a plain text file.
        Raises:
            - `FileNotFoundError`: if the file does not exist.
        """
    def save(self, filename:builtins.str) -> None:
        r"""
        Save the world configuration to the given file.
        """
    @staticmethod
    def level(level:builtins.int) -> World:
        r"""
        Retrieve the standard level (between `1` and `6`).
        Raises:
            - `ValueError`: if the level is invalid.
        """
    def set_exit_pos(self, exit_pos:typing.Sequence[tuple[builtins.int, builtins.int]]) -> None: ...
    def set_agents_positions(self, agents_positions:typing.Sequence[tuple[builtins.int, builtins.int]]) -> builtins.list[WorldEvent]:
        r"""
        Set the position of each agent.
        
        Returns:
            The list of events that occurred while the agents entered their new positions.
        
        Raises:
            - `InvalidWorldStateError`: if the number of positions is different from the number of agents.
            - `IndexError`: if a position is out of bounds.
        """
    def set_agent_position(self, agent_id:builtins.int, position:tuple[builtins.int, builtins.int]) -> builtins.list[WorldEvent]:
        r"""
        Set the position of a single agent.
        
        Returns:
            The list of events that occurred while the agent entered its new position.
        
        Raises:
           - `IndexError`: if the position is out of bounds.
           - `ValueError`: if the agent id does not exist.
        """
    def gem_at(self, position:tuple[builtins.int, builtins.int]) -> tiles.Gem:
        r"""
        Retrieve the gem at the given position.
        Raises:
          - `PyIndexError`: if the position is out of bounds.
          - `PyValueError`: if the tile at the given position is not a gem.
        """
    def source_at(self, position:tuple[builtins.int, builtins.int]) -> tiles.LaserSource:
        r"""
        Retrieve the laser source at the given position.
        Raises:
         - `PyIndexError`: if the position is out of bounds.
         - `PyValueError`: if the tile at the given position is not a laser source.
        """
    def seed(self, seed_value:builtins.int) -> None: ...
    def step(self, action: Action | list[Action]) -> builtins.list[WorldEvent]:
        r"""
        Simultaneously perform an action for each agent in the world.
        Performing a step generates events (see `WorldEvent`) to give information about the consequences of the joint action.
        
        Args:
           action: The action to perform for each agent. A single action is also accepted if there is a single agent in the world.
        
        Returns:
          The list of events that occurred while agents took their action.
        
        Raises:
            - `InvalidActionError` if an agent takes an action that is not available.
            - `ValueError` if the number of actions is different from the number of agents
        
        Example:
        ```python
        world = World("S1 G X S0 X")
        world.reset()
        events = world.step([Action.STAY, Action.EAST])
        assert len(events) == 1
        assert events[0].agent_id == 1
        assert events[0].event_type == EventType.GEM_COLLECTED
        
        events = world.step([Action.EAST, Action.EAST])
        assert len(events) == 2
        assert all(e.event_type == EventType.AGENT_EXIT for e in events)
        ```
        """
    def reset(self) -> None:
        r"""
        Reset the world to its original state.
        This should be done directly after creating the world.
        """
    def available_actions(self) -> builtins.list[builtins.list[Action]]:
        r"""
        Compute the list of available actions at the current time step for each agent.
        The actions available for agent `n` are given by `world.available_actions()[n]`.
        Returns:
           The list of available actions for each agent.
        """
    def available_joint_actions(self) -> builtins.list[builtins.list[Action]]:
        r"""
        Compute the list of available joint actions at the current time step.
        The result has shape (x, n_agents) where x is the number of joint actions available.
        Returns:
          The list of available joint actions.
        
        Example:
        ```python
        world = World(". .  .  . .\n. S0 . S1 .\n. X  .  X .\n")
        world.reset()
        assert len(world.available_joint_actions()) == len(Action.ALL) ** 2
        ```
        """
    def get_image(self) -> numpy.typing.NDArray[numpy.uint8]:
        r"""
        Renders the world as an image and returns it in a numpy array.
        Returns:
            The image of the world as a numpy array of shape (height * 32, width * 32, 3) with type uint8.
        """
    def set_state(self, state:WorldState) -> builtins.list[WorldEvent]:
        r"""
        Force the world to a given state
        Args:
            state: The state to set the world to.
        Returns:
            The list of events that occurred while agents entered their state.
        Raises:
            - `InvalidWorldStateError`: if the state is invalid.
        """
    def get_state(self) -> WorldState:
        r"""
        Return the current state of the world.
        """
    def __deepcopy__(self, _memo:dict) -> World:
        r"""
        Returns a deep copy of the object.
        
        Example:
        ```python
        from copy import deepcopy
        world = World("S0 X")
        world.reset()
        world_copy = deepcopy(world)
        world.step(Action.EAST)
        assert world.get_state() != world_copy.get_state()
        ```
        """
    def __getnewargs__(self) -> tuple:
        r"""
        This method is called to instantiate the object before deserialisation.
        It required "default arguments" to be provided to the __new__ method
        before replacing them by the actual values in __setstate__.
        """
    def __getstate__(self) -> tuple[builtins.str, WorldState]:
        r"""
        Enable serialisation with pickle
        """
    def __setstate__(self, state:tuple[builtins.str, WorldState]) -> None:
        r"""
        Enable deserialisation with pickle
        """
    def __repr__(self) -> builtins.str: ...

class WorldEvent:
    event_type: EventType
    agent_id: builtins.int
    def __new__(cls, event_type:EventType, agent_id:builtins.int) -> WorldEvent: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class WorldState:
    r"""
    A state in the `World` is defined by:
     - The position of each agent.
     - Whether each gem has been collected.
     - Whether each agent is alive.
    ## Using `WorldState`s
    ```python
    from lle import WorldState, World
    w = World("S0 . X")
    w.reset()
    s1 = w.get_state()
    s2 = WorldState([(0, 1), [], [True]])
    world.set_state(s2)
    ```
    ## Inheritance
    To inherit from `WorldState`, it is required to override the `__new__` method such that you its signature
    is compatible with `__init__`, i.e. it accepts the same leading arguments in the same order.
    Additionally, the `__new__` method **must** call the `super()` constructor with the parameters of the parent class, as shown below.
    ```python
    class SubWorldState(WorldState):
        def __init__(self, agents_positions: list[tuple[int, int]], gems_collected: list[bool], agents_alive: list[bool], x: int):
            super().__init__(agents_positions, gems_collected, agents_alive)
            self.x = x
        def __new__(cls, agents_positions: list[tuple[int, int]], gems_collected: list[bool], agents_alive: list[bool], *args, **kwargs):
            instance = super().__new__(cls, agents_positions, gems_collected, agents_alive)
            return instance
    ```
    """
    agents_positions: builtins.list[tuple[builtins.int, builtins.int]]
    r"""
    The position of each agent.
    """
    gems_collected: builtins.list[builtins.bool]
    r"""
    The collection status of each gem.
    """
    agents_alive: builtins.list[builtins.bool]
    r"""
    The status of each agent.
    """
    def __new__(cls, agents_positions:typing.Sequence[tuple[builtins.int, builtins.int]], gems_collected:typing.Sequence[builtins.bool], agents_alive:typing.Optional[typing.Sequence[builtins.bool]]=None) -> WorldState: ...
    def __init__(self, agents_positions:typing.Sequence[tuple[builtins.int, builtins.int]], gems_collected:typing.Sequence[builtins.bool], agents_alive:typing.Optional[typing.Sequence[builtins.bool]]=None) -> None: ...
    def as_array(self) -> numpy.typing.NDArray[numpy.float32]: ...
    @staticmethod
    def from_array(array:typing.Sequence[builtins.float], n_agents:builtins.int, n_gems:builtins.int) -> WorldState: ...
    def __deepcopy__(self, _memo:dict) -> WorldState: ...
    def __getstate__(self) -> tuple[builtins.list[builtins.bool], builtins.list[tuple[builtins.int, builtins.int]], builtins.list[builtins.bool]]: ...
    def __setstate__(self, state:tuple[typing.Sequence[builtins.bool], typing.Sequence[tuple[builtins.int, builtins.int]], typing.Sequence[builtins.bool]]) -> None: ...
    def __getnewargs__(self) -> tuple[builtins.list[tuple[builtins.int, builtins.int]], builtins.list[builtins.bool], typing.Optional[builtins.list[builtins.bool]]]: ...
    def __repr__(self) -> builtins.str: ...
    def __hash__(self) -> builtins.int: ...
    def __richcmp__(self, other:WorldState, cmp:int) -> builtins.bool: ...

class Action(Enum):
    r"""
    An action that can be taken in the world by the agents.
    """
    NORTH = ...
    SOUTH = ...
    EAST = ...
    WEST = ...
    STAY = ...

    delta: tuple[builtins.int, builtins.int]
    r"""
    The (i, j) position delta in coordinates for this action.
    """

    value: builtins.int
    r"""
    The integer value of this action.
    """

    name: builtins.str
    r"""
    The string name of this action.
    """

    ALL: builtins. list[Action]
    r"""
    Ordered list of actions
    """

    N: builtins. int
    r"""
    The number of actions (cardinality of the action space)
    """

    def __new__(cls, value:builtins.int) -> Action: ...

    def __hash__(self) -> builtins.int: ...

    def __repr__(self) -> builtins.str: ...

    def opposite(self) -> Action:
        r"""
        The opposite action of this action.
        Note: STAY is its own opposite.
        """

class EventType(Enum):
    r"""
    An enumeration of the events that can occur in the world.
    """
    AGENT_EXIT = ...
    GEM_COLLECTED = ...
    AGENT_DIED = ...

    def __repr__(self) -> builtins.str: ...

    def __hash__(self) -> builtins.int: ...

