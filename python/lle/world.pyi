# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import enum
import numpy
import numpy.typing
import typing
from lle.agent import Agent
from lle.tiles import Gem, Laser, LaserSource

class World:
    r"""
    The `World` represents the environment in which the agents evolve.
    A world is created from a string where each character represents a tile.
    There are 6 predefined levels for convenience.

    ```python
    from lle import World
    # Create from a predefined level
    w1 = World.level(5)
    # Create from a file
    w2 = World.from_file("my_map.txt")
    # Create from a string
    w3 = World("S0 X")
    ```
    """
    @property
    def exit_pos(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""
        The positions of the exits tiles.
        """
    @exit_pos.setter
    def exit_pos(self, value: builtins.list[tuple[builtins.int, builtins.int]]) -> None: ...
    @property
    def random_start_pos(self) -> builtins.list[builtins.list[tuple[builtins.int, builtins.int]]]:
        r"""
        The possible random start positions of each agent.
        """
    @property
    def wall_pos(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""
        The positions of the walls.
        """
    @property
    def void_pos(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""
        The positions of the void tiles.
        """
    @property
    def height(self) -> builtins.int:
        r"""
        The height of the world (in number of tiles).
        """
    @property
    def width(self) -> builtins.int:
        r"""
        The width of the world (in number of tiles).
        """
    @property
    def n_gems(self) -> builtins.int:
        r"""
        The number of gems in the world.
        """
    @property
    def n_agents(self) -> builtins.int:
        r"""
        The number of agents in the world.
        """
    @property
    def all_states2(self) -> builtins.list[WorldState]:
        r"""
        Returns an iterator over all possible states of the world.
        """
    @property
    def all_states(self) -> typing.Iterator[WorldState]:
        r"""
        Returns an iterator over all possible states of the world.
        """
    @property
    def all_states_old(self) -> WorldStateIterator:
        r"""
        Returns an iterator over all possible states of the world.
        """
    @property
    def world_string(self) -> builtins.str:
        r"""
        Compute the world configuration string from the `World`.
        If possible, the string is returned in "plain text" format.
        Otherwise, it is returned in toml format.
        """
    @property
    def image_dimensions(self) -> tuple[builtins.int, builtins.int]:
        r"""
        The dimensions (in pixels) of the image redered (width, height)
        """
    @property
    def gems_collected(self) -> builtins.int:
        r"""
        The number of gems collected by the agents so far since the last reset.
        """
    @property
    def agents_positions(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""
        The (i, j) position of each agent.
        """
    @property
    def gems(self) -> builtins.list[Gem]:
        r"""
        All the gems of the environment.
        """
    @property
    def lasers(self) -> builtins.list[Laser]:
        r"""
        Every laser tile in the world.
        """
    @property
    def laser_sources(self) -> builtins.list[LaserSource]:
        r"""
        All the laser sources of the environment
        """
    @property
    def start_pos(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""
        The start position of each agent for this reset.
        """
    @property
    def agents(self) -> builtins.list[Agent]:
        r"""
        The list of agents in the world.
        """
    @property
    def n_laser_colours(self) -> builtins.int:
        r"""
        The number of different laser colours in the world.
        """
    def __new__(cls, map_str: builtins.str) -> World: ...
    def __init__(self, map_str: builtins.str) -> None:
        r"""
        Constructs a World from a string.

        Raises:
            `RuntimeError`: if the file is not a valid level.
            `ValueError` if the file is not a valid level (inconsistent dimensions or invalid grid).
        """
    @staticmethod
    def from_file(filename: builtins.str) -> World:
        r"""
        Parse the content of `filename` to create a World.

        The file can either be a toml or a plain text file.
        Raises:
            `FileNotFoundError`: if the file does not exist.
        """
    def save(self, filename: builtins.str) -> None:
        r"""
        Save the world configuration to the given file.
        """
    @staticmethod
    def level(level: builtins.int) -> World:
        r"""
        Retrieve the standard level (between `1` and `6`).
        Raises:
            `ValueError`: if the level is invalid.
        """
    def set_agents_positions(self, agents_positions: typing.Sequence[tuple[builtins.int, builtins.int]]) -> builtins.list[WorldEvent]:
        r"""
        Set the position of each agent.

        Returns:
            The list of events that occurred while the agents entered their new positions.

        Raises:
            `InvalidWorldStateError`: if the number of positions is different from the number of agents.
            `IndexError`: if a position is out of bounds.
        """
    def set_agent_position(self, agent_id: builtins.int, position: tuple[builtins.int, builtins.int]) -> builtins.list[WorldEvent]:
        r"""
        Set the position of a single agent.

        Returns:
            The list of events that occurred while the agent entered its new position.

        Raises:
           `IndexError`: if the position is out of bounds.
           `ValueError`: if the agent id does not exist.
        """
    def gem_at(self, position: tuple[builtins.int, builtins.int]) -> Gem:
        r"""
        Retrieve the gem at the given position.
        Raises:
          `PyIndexError`: if the position is out of bounds.
          `PyValueError`: if the tile at the given position is not a gem.
        """
    def source_at(self, position: tuple[builtins.int, builtins.int]) -> LaserSource:
        r"""
        Retrieve the laser source at the given position.
        Raises:
         `PyIndexError`: if the position is out of bounds.
         `PyValueError`: if the tile at the given position is not a laser source.
        """
    def seed(self, seed_value: builtins.int) -> None: ...
    def step(self, action: Action | list[Action]) -> builtins.list[WorldEvent]:
        r"""
        Simultaneously perform an action for each agent in the world.
        Performing a step generates events (see `WorldEvent`) to give information about the consequences of the joint action.

        Args:
           action: The action to perform for each agent. A single action is also accepted if there is a single agent in the world.

        Returns:
          The list of events that occurred while agents took their action.

        Raises:
            `InvalidActionError` if an agent takes an action that is not available.
            `ValueError` if the number of actions is different from the number of agents

        Example:
        ```python
        world = World("S1 G X S0 X")
        world.reset()
        events = world.step([Action.STAY, Action.EAST])
        assert len(events) == 1
        assert events[0].agent_id == 1
        assert events[0].event_type == EventType.GEM_COLLECTED

        events = world.step([Action.EAST, Action.EAST])
        assert len(events) == 2
        assert all(e.event_type == EventType.AGENT_EXIT for e in events)
        ```
        """
    def reset(self) -> None:
        r"""
        Reset the world to its original state.
        This should be done directly after creating the world.
        """
    def available_actions(self) -> builtins.list[builtins.list[Action]]:
        r"""
        Compute the list of available actions at the current time step for each agent.
        The actions available for agent `n` are given by `world.available_actions()[n]`.
        Returns:
           The list of available actions for each agent.
        """
    def available_joint_actions(self) -> builtins.list[builtins.list[Action]]:
        r"""
        Compute the list of available joint actions at the current time step.
        The result has shape (x, n_agents) where x is the number of joint actions available.
        Returns:
          The list of available joint actions.

        Example:
        ```python
        world = World(". .  .  . .\n. S0 . S1 .\n. X  .  X .\n")
        world.reset()
        assert len(world.available_joint_actions()) == len(Action.variants()) ** 2
        ```
        """
    def get_image(self) -> numpy.typing.NDArray[numpy.uint8]:
        r"""
        Renders the world as an image and returns it in a numpy array.
        Returns:
            The image of the world as a numpy array of shape (height * 32, width * 32, 3) with type uint8.
        """
    def set_state(self, state: WorldState) -> builtins.list[WorldEvent]:
        r"""
        Force the world to a given state
        Args:
            state: The state to set the world to.
        Returns:
            The list of events that occurred while agents entered their state.
        Raises:
            `InvalidWorldStateError`: if the state is invalid.
        """
    def get_state(self) -> WorldState:
        r"""
        Return the current state of the world.
        """
    def __deepcopy__(self, _memo: dict) -> World:
        r"""
        Returns a deep copy of the object.

        Example:
        ```python
        from copy import deepcopy
        world = World("S0 X")
        world.reset()
        world_copy = deepcopy(world)
        world.step(Action.EAST)
        assert world.get_state() != world_copy.get_state()
        ```
        """
    def __getnewargs__(self) -> tuple:
        r"""
        This method is called to instantiate the object before deserialisation.
        It required "default arguments" to be provided to the __new__ method
        before replacing them by the actual values in __setstate__.
        """
    def __getstate__(self) -> tuple[builtins.str, WorldState]:
        r"""
        Enable serialisation with pickle
        """
    def __setstate__(self, state: tuple[builtins.str, WorldState]) -> None:
        r"""
        Enable deserialisation with pickle
        """
    def __repr__(self) -> builtins.str: ...

@typing.final
class WorldEvent:
    @property
    def event_type(self) -> EventType: ...
    @property
    def agent_id(self) -> builtins.int: ...
    def __new__(cls, event_type: EventType, agent_id: builtins.int) -> WorldEvent: ...
    def __str__(self) -> builtins.str: ...
    def __repr__(self) -> builtins.str: ...

class WorldState:
    r"""
    A state in the `World` is defined by:
     - The position of each agent.
     - Whether each gem has been collected.
     - Whether each agent is alive.
    ## Using `WorldState`s
    ```python
    from lle import WorldState, World
    w = World("S0 . X")
    w.reset()
    s1 = w.get_state()
    s2 = WorldState([(0, 1), [], [True]])
    world.set_state(s2)
    ```
    ## Inheritance
    To inherit from `WorldState`, it is required to override the `__new__` method such that you its signature
    is compatible with `__init__`, i.e. it accepts the same leading arguments in the same order.
    Additionally, the `__new__` method **must** call the `super()` constructor with the parameters of the parent class, as shown below.
    ```python
    class SubWorldState(WorldState):
        def __init__(self, agents_positions: list[tuple[int, int]], gems_collected: list[bool], agents_alive: list[bool], x: int):
            super().__init__(agents_positions, gems_collected, agents_alive)
            self.x = x
        def __new__(cls, agents_positions: list[tuple[int, int]], gems_collected: list[bool], agents_alive: list[bool], *args, **kwargs):
            instance = super().__new__(cls, agents_positions, gems_collected, agents_alive)
            return instance
    ```
    """
    @property
    def agents_positions(self) -> builtins.list[tuple[builtins.int, builtins.int]]:
        r"""
        The position of each agent.
        """
    @agents_positions.setter
    def agents_positions(self, value: builtins.list[tuple[builtins.int, builtins.int]]) -> None:
        r"""
        The position of each agent.
        """
    @property
    def gems_collected(self) -> builtins.list[builtins.bool]:
        r"""
        The collection status of each gem.
        """
    @gems_collected.setter
    def gems_collected(self, value: builtins.list[builtins.bool]) -> None:
        r"""
        The collection status of each gem.
        """
    @property
    def agents_alive(self) -> builtins.list[builtins.bool]:
        r"""
        The status of each agent.
        """
    @agents_alive.setter
    def agents_alive(self, value: builtins.list[builtins.bool]) -> None:
        r"""
        The status of each agent.
        """
    def __new__(
        cls,
        agents_positions: typing.Sequence[tuple[builtins.int, builtins.int]],
        gems_collected: typing.Sequence[builtins.bool],
        agents_alive: typing.Optional[typing.Sequence[builtins.bool]] = None,
    ) -> WorldState: ...
    def __init__(
        self,
        agents_positions: typing.Sequence[tuple[builtins.int, builtins.int]],
        gems_collected: typing.Sequence[builtins.bool],
        agents_alive: typing.Optional[typing.Sequence[builtins.bool]] = None,
    ) -> None: ...
    def as_array(self) -> numpy.typing.NDArray[numpy.float32]: ...
    @staticmethod
    def from_array(array: typing.Sequence[builtins.float], n_agents: builtins.int, n_gems: builtins.int) -> WorldState: ...
    def __deepcopy__(self, _memo: dict) -> WorldState: ...
    def __getstate__(
        self,
    ) -> tuple[builtins.list[builtins.bool], builtins.list[tuple[builtins.int, builtins.int]], builtins.list[builtins.bool]]: ...
    def __setstate__(
        self,
        state: tuple[typing.Sequence[builtins.bool], typing.Sequence[tuple[builtins.int, builtins.int]], typing.Sequence[builtins.bool]],
    ) -> None: ...
    def __getnewargs__(
        self,
    ) -> tuple[
        builtins.list[tuple[builtins.int, builtins.int]], builtins.list[builtins.bool], typing.Optional[builtins.list[builtins.bool]]
    ]: ...
    def __repr__(self) -> builtins.str: ...
    def __hash__(self) -> builtins.int: ...
    def __richcmp__(self, other: WorldState, cmp: int) -> builtins.bool: ...

class WorldStateIterator: ...

@typing.final
class Action(enum.Enum):
    r"""
    An action that can be taken in the world by the agents.
    """

    NORTH = ...
    SOUTH = ...
    EAST = ...
    WEST = ...
    STAY = ...

    @property
    def delta(self) -> tuple[builtins.int, builtins.int]:
        r"""
        The (i, j) position delta in coordinates for this action.
        """
    @property
    def value(self) -> builtins.int:
        r"""
        The integer value of this action.
        """
    @staticmethod
    def variants() -> builtins.list[Action]:
        r"""
        Ordered list of all actions
        """
    @staticmethod
    def cardinality() -> builtins.int:
        r"""
        The number of actions
        """
    def __new__(cls, value: builtins.int) -> Action: ...
    def __hash__(self) -> builtins.int: ...
    def __repr__(self) -> builtins.str: ...
    def opposite(self) -> Action:
        r"""
        The opposite action of this action.
        Note: STAY is its own opposite.
        """
    def __deepcopy__(self, _memo: dict) -> Action: ...
    def __getstate__(self) -> builtins.int: ...
    def __setstate__(self, state: builtins.int) -> None: ...
    def __getnewargs__(self) -> tuple: ...

@typing.final
class EventType(enum.Enum):
    r"""
    An enumeration of the events that can occur in the world.
    """

    AGENT_EXIT = ...
    GEM_COLLECTED = ...
    AGENT_DIED = ...

    def __repr__(self) -> builtins.str: ...
    def __hash__(self) -> builtins.int: ...
